/*

백트래킹(Backtracking)
기본적으로 백트래킹의 로직은 '가능한 모든 방법을 탐색한다.'
DFS 완전탐색방법. 

시간이 오래걸리는 단점이 있다.
애초에 가방없는길은 가지치기.
dfs

트리가 있다고 쳤을때. 가지치기. 가능성이 있는 노드. 유망한 노드.
아예 메모리 제이션을 하지 않고 가지를 않는것이다.

백트래킹을 하는 순서 
	dfs수행 - 먼저 평소와 같이 깊이 우선 탐색을 수행하여 노드를 찾는다.
	유망한 노드 검토 - 방문한 노드를 퐇마해서 유망한 노드이면 서브트리로 이동하고 그렇지 않으면 백트래킹을 수행한다.
	 : 플레이타임 늘릴려고 쾌스트 까지 가게 하는것

	 방문한 노드의 하위노드로 이동하여 다시 재귀를 통해 dfs를 수행한다.
	 백트래킹을 수행한다는 것은 방문한 노드를 가지치기를 하고 사우이 노드로 백트래킹 한 후 dfs를 다시 수행하는것.



*/

#include <stdio.h>
#include <math.h>

const int MAX = 16;
int col[MAX];
int n;
int answer = 0;

/*
해당 노드가 유망한 노드인지 확인하는 함수
첫번째 열부터 해당노드까지 for문을 돌아서 같은 행에 퀸이 있는지 , 대각선에 퀸이 있는지를 검사.
검사를 모두 마치고 검사를 통과했다면 true를 반환하여 다음절차인
서브트리로 이동할수 있게 된다.
*/
bool Check(int row)
{
	//이전 열들을 탐색하면 유망한 노드인지 확인
	for (int i = 1; i < row; i++)
	{
		if (col[i] == col[row])
			return false;
		//대각선검사.
		if (abs(col[i] - col[row]) == abs(i - row))
			return false;
	}
	return true;
}

/*
dfs함수는 현재 노드를 검사하여 유망하면 하위노드로 이동하고 그렇지 않으면 백트래킹을 수행하여 해당 노드를 가지치기 한다.

먼저 현재 도착한 노드의 좌표를 저장한다.
그리고 두번째 절차인 유망한 노드인지를 검도하고 유망하면 서브트리로 
이동하기 위해 dfs를 재수행한다.
그렇지 않으며 ㄴ백트래킹을 수행하여 해당노드를 가지치기 한다.

마지막으로 해당 열 값이 체스판의 크기를 초과하면
마지막 노드까지 탐색이 완료 되었기 때문에 정답 카운트를 1 증가한다.
*/
void DFS(int row)
{
	//가지치기를 안당했다는것은 경우의수다.
	if (row > n)
		answer++;
	else
	{
		for (int i = 1; i <= n; i++)
		{
			//현재 위치하고 있는 노드 좌표를 저장
			//row: 열, i: 행
			col[row] = i;
			
			//2. 유망한 노드 검토
			if (Check(row) == true)
			{
				//3. 서브트리로 이동.
				DFS(row + 1);
			}
			else
			{
				//4. 백트래킹 수행
				//해당 노드 가지치기
				col[row] = 0;
			}
		}
	}
}
/*
체스판의 크기 n을 입력 받고 col은 행의 좌표를 담고 있다.
처음에는 col[1] = 1이 담기기 때문에 첫번째 줄에 
배치되는 퀸의 위치는 1,1이 된다.
다음 백트래킹의 첫번째 절차인 dfs를 수행하여 다음 노드로 이동한다.

*/
int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) {
		/*
			첫번째 퀸의 시작점은 행을 기준
			(i=1) -> 1,1
			(i=2) -> 1,2
		*/
		col[1] = i;
		//1.dfs수행 다음열인 2열로 이동
		DFS(2);
	
	}
	printf("%d", answer);

	return 0;
}