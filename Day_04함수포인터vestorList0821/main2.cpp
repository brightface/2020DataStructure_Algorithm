#include <iostream>
#include <vector>
#include <list>
using namespace std;

/*
	자료구조 종류
	1. 단순 자료구조
	- int, float, char

	2. 선형 자료구조
	- 한 방향으로 일정하게( 일자로 ) 이동하는 것을 선형 자료구조형이라고 한다.
	- 배열

	3. 비선형 자료구조
	-

	4. 파일 ( 특수 )
	- 파일은 각자의 특수한 자료구조의 형태를 가지고 있다.

	// vector 의 특징
	- vector 는 메모리 상에 일정하게 연결되어 있다. 그래서 vector 는 물리적으로 연결되어 있다고 말할 수 있다. 
	- vector 의 검색은 O(1) 의 복잡도를 가지고 있다.

	// list 의 특징
	- list 또한 선형 자료구조의 일종이다.
	- list 는 메모리에 연속적으로 나열되어 있을 필요가 없다.
	- linked 를 이용하여 다음 노드의 주소를 가져올 수 있기 때문에 list 는 결국 물리적이 아닌 논리적으로 연결되어 있다고 말할 수 있다.
	- list 에는 RanIt 이 없다, 이진 탐색을 사용할 수 없다 ( 첨자가 필요한 함수들은 사용할 수 없다 )
	- list 는 특정한 값을 찾을 때 무조건 Head Node 부터 순회를 해서 찾아야 한다. ( list 의 검색은 O(n) 의 복잡도를 가지고 있다. )
	- list 는 vector 에 비해서 중간 삽입, 삭제가 좀 더 편하다.
	- 임의 위치를 상수시간에 엑세스 할 수 없으며 반드시 순회를 해야만 원하는 데이터를 찾을 수 있다.
	- 그래서 임의 접근 반복자를 요구하는 sort / binary_search 같은 알고리즘은 사용할 수 없다.

	// vector 와 list 의 차이점
	1. vector 는 연속적으로 나열되어 있기 때문에, vector 의 요소들에 임의접근(RanIt) 이 가능하지만 list 는 노드들이 흩어져 있기 때문에
	그냥 양방향으로 이동만 가능하다. 그래서 반복자가 순서값으로 접근하는 [] 연산자를 지원하지 않고, 당연히 at() 도 지원하지 않는다.
	
	2. 각 요소들이 노드로 할당되어 링크에 의해 논리적으로 연결되어 있으므로 삽입 삭제를 수행할 수 있다.
	요소들이 인접하지 않아도 상관없기 때문에, 삭제시에 메모리 이동을 할 필요가 없고, 위치에 상관없이 상수시간내에 삽입 삭제를 할 수 있다.
	제일 앞에 요소를 삽입 삭제하는 push_front, pop_front 함수가 제공된다. 이에 비해 벡터는 중간에서 삽입 삭제를 할 때 요소를 밀거나
	당겨야되서 상대적으로 느랃. 또한 속도 희생없이 크기를 늘리던지 줄일 수 있기 때문에 미리 크기를 걱정할 필요가 없다. 
	그래서 capacity 라던지 reserve 함수를 쓸 필요도 없다.

	3. 링크 구조로 인해 메모리 소모량은 벡터보다 훨씬 더 많다. 요소를 저장하는 노드는 "무조건" 동적할당 해야하며, 
	요소간의 순서를 기억하기 위한 링크도 별도의 메모리를 소모한다. 또한 삽입 삭제시마다 노드를 할당 해제하는 과정을 
	계속 반복하기 때문에 메모리 단편화 현상도 심하다.
*/

/*
	메모리 단편화 해결 방법
	- 메모리 풀링 기법
	1. 미리 메모리를 할당한다.
	2. 정해진 자료형의 크기만큼 할당을 받는다.
	3. 삭제할 때던 할당할 때던 정해진 구간의 메모리에서 할당, 해제를 진행한다.
*/

int main()
{
	//vector<int> vec;
	//for (int i = 0; i < 7; i++)
	//{
	//	vec.push_back(i);
	//	cout << vec.capacity() << endl;
	//	// capacity : 메모리 공간을 몇 개를 할당 받았는지.
	//	// 즉, 7 개를 할당 받았고 크기는 실질적으로 (int * 7) 의 Byte 의 크기를 가진다.
	//	// capacity 는 6 개 까지는 1 개씩 받고 6 개를 분기점으로 넘어가면 좀 더 넉넉하게 크기를 잡아온다.
	//}

	// Resize 는 공간을 정해진 만큼 재할당
	//vec.resize(10000);

	// Assign 은 초기에 공간을 정해놓고 할당 받는 것
	//vec.assign(10000, VertexColor());


	//vector<int> vec;
	//vec.push_front();	 // 벡터는 앞에 추가하는 기능이 없다.
	//vec.pop_front();   // 벡터는 앞에 삭제 요소도 없다.
	list<int> l;
	//l.push_front();	// list 는 둘 다 가능ㅎ다.
	//l.pop_front();	// list 는 둘 다 가능ㅎ다.
	l.push_back(10);
	l.push_back(20);
	l.push_front(0);
	l.push_front(-10);
	/*for (int i = 0; i < l.size(); i++)
		l[i];*/	// 안된다.
	list<int>::iterator iter = l.begin();
	for (iter = l.begin(); iter != l.end(); ++iter)
		cout << *iter << " ";
	cout << endl;
		
	///////////////////////////////////////////////////////////////////////////
	// 중간 삽입
	iter = l.begin();
	iter++;	iter++;
	// iter += 3; // 안된다.
	l.insert(iter, 100);
	for (iter = l.begin(); iter != l.end(); ++iter)
		cout << *iter << " ";
	cout << endl;

	///////////////////////////////////////////////////////////////////////////
	// 중간 값 제거
	iter = l.end();
	iter--;	iter--;
	l.erase(iter);
	for (iter = l.begin(); iter != l.end(); ++iter)
		cout << *iter << " ";
	cout << endl;

	///////////////////////////////////////////////////////////////////////////
	// 특정값 제거 ( 같은 값이 있으면 다 지워버린다. )
	l.remove(0);
	for (iter = l.begin(); iter != l.end(); ++iter)
		cout << *iter << " ";
	cout << endl;

	///////////////////////////////////////////////////////////////////////////
	// 모든 원소 제거
	l.clear();

	return 0;
}