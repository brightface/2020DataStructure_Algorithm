#pragma once

/*
해싱(Hashing)
	사용처 
	보안 : 데이터의 위변조를 막기위해 전자서명이나 보안 알고리즘에 사용
	자료구조 : 해쉬테이블이라 해가지고 기억공간에 저장된 정보를 보다 빠르게 검색하기 위해 상대주소가 아닌 해시 테이블을 생성하는 방식
	엄청 빠르게 찾을수 있어. 
	상수시간의 접근속도를 가지는게 있다. 배열 : 상수시간이다.
	가장빠르다. O(1)
	키값을 가지고 한다. 
	탐색키를 가지고 한다.

	대부분의 탐색 방법들은 탐색 키를 저장된 키값과 반복적으로 비교해가며 탐색을 원하는 항목에 접근하게 된다.
	반면 해싱은 키값에 직접 산술적인 연산을 적용하여 항목이 저장되어 있는 테이블의 주소를 계산하여 항목에 접근한다.

	1차원적인 자료구조가 아니다.
	unordered map 연관배열 2차원적인 자료구조. 

	해쉬 function 어떤 키값을 넣으면 주소값으로 변환시켜준다.
	접근을 할때 일반적으로 스트링의 키랎을 쓴다. 주소로 한방에 접근한다.
	왜가능하냐면 똑같은 데이터를 넣음 똑같은 값이 넣을수 밖에 없다. 
	이렇게 키 값의 연산에 의해 직접접근이 가능한 구조를 해시테이블이라 부르고, 해시 테이블을 이용한 탐색을 해싱이라 한다.

	키들의 비교에 의한 탐색은 정렬이 안되어 있으면 
	이진트리같은 경우 최악의 경우 n / 노드 개수만큼 돌면돼
	정렬되어있으면 o(log n)이다.
	정렬이 되어있는 경우의 시간 복잡도가 o(logn)이건 이진탐색 알고리즘이나 이전탐색트리.

	해싱이 나오게된 배경>
	위의 시간복잡도보다 더욱 빠른 탐색을 필요로 할때이다.
	해싱은 이론적으로 o(1)의 상수시간에 탐색을 끝마칠수 있다.
	(평균적으로 그렇지는 않다)

	이론적으로 KMP도 N+M 이다.
	해싱 function을 어떻게 만드느냐에 따라 다르겟지.
	반복문이 돌아간다. 더블해싱을 쓴다. O(N)이 동시에 여러개의 데이터를 다루는 게 아니니까.
	 
	 보통 dictionary(사전구조)와 같은 자료구조를 구현할 때 최상의 선택이 된다.
	 
	 사전구조는 다른말로 map이라 부른다. table이라 부르기도 한다.
	 사전구조는 탐색 키, 그리고 탐색 키와 관련있는 값 이렇게 두가지 종류의 필드를 가진다.
	 사전이라는 말 자체 : 영어단어가 키값이고, 단어의 뜻이 값이 된다. 
	 값이 여러개가 잇는것 있자나.
	 키값의 중복을 허용하는경우도 있고 안하는경우도 있다.

	 동의어를 허용한다. 같은 키값을 어떻게 처리할것인가. 충돌을 피하기 위한것. 암호화 이야기 했었잖아.
	 암호화 = 소수를 가지고 한다. 소수의 규칙성이 발견이 안됬다. 리만가설. 모든 보안체계는 갈아 엎어져야돼. 소수의 규칙성이 알려지면

	 충돌이 나는게 발견이 되었어. 4(32비트)바이트에서 64비트(8바이트) 테이블을 넣는것으로 변경되었어.
	 256비트(32바이트) https : ssm 이다. //충돌이 된다면 올릴수 있겟지?
	 32비트: 4바이트

	 데이터베이스에 특화 avl 트리

	 연관배열 rb트리. 많이 쓴다. 

	 해싱은 데이터 베이스에서 많이 써. 보안에서 써.
	 더 빠른 접근이 가능하겠지. 
	 구현이 어려워
	 데이터 테이블에다가 보안적인것 암호화가 되어잇는것. 서버라든지 이런것에서 많이 써.
	 -------------------------------------------------------------------------------------------------------

단어정리

해싱함수(Hashing function)
	- 키값으로부터 레코드의 물리적 주소로 사상시키는 함수.	
	pair가 하나의 레코드야.
	사상 : map , unmap 하는게 사상이야.
	키값을 가지고 물리적 주소로 변환을 시킨다.

	-데이터의 무결성 검증. //이건 서버에서 한다. 유저는 클라, 회사는 서버. //유저가 핵쏘면 이상한값. 서버는 정상적인것인지 검사를하게돼
	//그게 무결성검증
	: 변조 여부를 파악하기 위해 임의 길이 메세지를 고정길이 메세지로 변환해서 사용한다.

해시 키값 
	-해싱함수가 레코드 주소를 계산하기 위해 사용하는 레코드의 키값을 말함
해시 테이블
	-해싱함수에 의해 계산된 주소
	-키 연산에 의해 직접 접근이 가능한 구조의 기억장소
버킷
	-하나의 주소를 가지면서 하나 이상의 레코드를 저장할 수 있는 파일의 한 구역 (중복을 안하면 하나의 버킷에 하나의 레코드가 들어간다)
	-크기가 같은 주소에 포함 가능한 레코드의 수
	-여러개의 슬롯으로 구성됨
슬롯
	- 한개의 레코드를 저장 할 수 있는 공간
직접파일(direct file)
	- 해싱 방법을 기초로 하여 만들어진 파일
	- 휘발성이니까 파일로 관리하는게 더 편하다.
	- 레코드를 식별하기 위한 키값과 저장장치에 저장되어 있는 레코드 사이의 사상관계가 성립되어있어야함.
		사상 == 추상화
		맵핑한다 == 사상한다.
	- 버킷이 여러개가 모여서 파일을 구성한다.

충돌 
	-서로다른 레코드들이 같은 주소로 변환 되는 경우 (충돌을 해결하기위한방법이고 아까그건) 
오버 플로우
	- 더 이상 빈자리가 없는 과잉상태
	- 버킷에 레코드들이 가득 한 상태 - 2배로 늘려버린다. 크기가 고정되어있다. 오버플로우 많이 큰 동적해싱 크기를 늘리고 문제가 안생겨.
	개념이 복잡한거지.

해싱 구현 기법
	정적 해싱(static hashing)
		- 고정 크기의 배열을 이용한 방법.
		- 버킷에 대이터 넣는다 그랬잖아. 버킷 주소의 집합을 고정. 0~999의 주소의 버킷을 고정
		- 해쉬 함수를 만들때. 0~999 주소를 해쉬함수를 통해서  버킷주소를 만들어야 할것 아니야. 
		- 현재 파일의 크기를 고려하여 해쉬함수를 결정한다.
		- 미래의 어떤 시점을 기점으로 파일 크기를 예상하여 해쉬함수를 결정한다. (데이터 3만개인데 주소를 100개만 있으면 안되잖아)
		- 파일의 크기가 커짐에 따라 주기적으로 해싱 구조를 재구성을 해야한다.
		(해싱이라는것 자체가 자료구조를 의미한다)
		- 비교적 구현이 쉽고 간단하다. (동적해싱에 비교해서 구현이 쉽고 간단)
		- 버킷의 크기를 너무 작게 잡으면 충돌이 나고,
		너무 크게 잡으면 메모리 낭비의 우려가 있다. 버킷집합의 주소를 고정한다는게 원하는 위치에 바로 접근이 가능하다.
	
		(데이터가 많아지면 많아지는대로 구조를 재구성해야한다.)데이터가 증가하면서 보존성이 떨어진다.

	정적 해싱함수를 잡는 기법
		- 제산법
			나머지 연산자를 이용하여 버킷주소를 계산하는 방법.
			//한버킷에 너무 많이 들어갈수가 있다.
			버킷 주소 = key % 전체 버킷 크기
			해시된 주소가 고르게 분포 되지 않을수 있기 땜누에 일반적으로 전체 버킷의 크기를 소수(Prime number)로 하여 
			성능을 향상시킨다.
			부하율(load factor, 전체 버킷에서 사용중인 버킷의 비율) 70~80%가 적당하다. 가득채우면 안돼. 문제가 발생할수 있다.
		
		- 중간 제곱법
			123 -> 15129 (중간에 있는 1만 빼서 주소로 쓴다)
			키값을 제곱한 후 결과값의 중간부분에 있는 몇비트만 선택하여 주소로 사용
			제곱된 겨로가의 중간 비트는 일밙거으로 모든 키값의 영향을 받기 때문에 
			키를 구성하는 일부 문자가 같을 지라도 서로 다른 결과값을 가질 확률이 높다. 중간의 몇비트를 선택할건지는 알아서 하면돼

		- 폴딩법(folding)
			123456789 
			123 + 456 + 789 
			123 + 654 + 789 (뒤집어) 경계면을 가지고 접는다. 123을 기점으로 접는것이다.
			키를 마짐가 부분을 제외한 모든 부분의 길이가 동일하게 여러부분으로 
			나누고, 이들 부분을 모두 더하거나, XOR 연산을 하여서 버킷 주소로 이용하는 방법이다.
			- 이동 폴딩(shift folding) : 각 부분의 값을 계산하기 위해 마지막을 제외한 모든 부븐을 이동시켜 
			최하위 비트가 마지막 부분의 자리와 일치하도록 우측 끝을 맞추어 더한 값을 버킷 주소로 사용하는 방법. / 오른쪽 끝으로 shift 시킨다.
			- 경계 폴딩(boundary folding) : 원래의 키값을 여러부분으로 나눈뒤, 나누어진 각부분의 경계선을 종이 접듯이 접어 역으로 정렬한 다음 같은 자리에
			위치한 수를 버킷주소로 사용하는 방법.

		- 숫자 분석법(digit - analysis)
			키를 구성하는 수들이 모든 키들 내에서 각 자리별로 어떤 분포인지를 조사하여 비교적 고른분포를 나타내는 자릿수를
			필요한 만큼 선택하여 버킷 주로로 쓰는 방법. ex)전화번호부 
			010 7747 6039
			010 5109 4453
			010 7111 9088 
			빈도수가 많은애를 선택해서 두자리를 선택한다 하자. 7 4
			-숫자를 분석한다.
			파일의 키값이 이미 알려진 정적 파일인 경우에 유용하다. <이미 데이터가 있고> 분보가 높은 애들을 골라야 하잖아. 
			비슷한 숫자 배열이 나오는 비트는 제거하고 중복이 적은 비트를 선택한다.(일반적으로)

		- 기수 변환법(radix-exchange)
			10진수인데 16진수라 가정을 하고 쓰겠다. 안에있는 몇비트만 그리고 쓰겟다. (기수가 진법)
			어떤 진법으로 변환된 키를 다른 진법으로 간주하고 키를 변환시켜서 버킷의 주소를 얻는방법.
			배열의 크기가 10의 거듭제곱으로 표현되어 변환된 해당 버킷주소가 배열의 크기를 초과할때는(초과할 확률이 높겠지) 
			버킷 주소의 최하위 자리부터 배열의 크기가 허용하는 거듭제곱 자리수만큼 취하여 주소로 사용한다.

		- 무작위 방법(랜덤한 숫자가 나오면 키값에 곱해서 쓰겠다) : 난수발생. 할때마다 시드값을 다르게 하면 안되고. 그게 달라지면 안돼.


			
동적해싱
	해쉬테이블, 버킷 이 동적이다. 동적해싱은 데이터 증감에 따라 배열의 크기를 동적으로 변화시켜며 오버플로우 발생시 테이블의 크기를 2배수로 확장한다.
	원래 트리를 쓰거든 000 비트를 하나 더 늘린다. 그러면 2배가 되겠지 디렉토리 2진수니까.
	- 이진트리를 한 레벨이 더 추가가 되는거야. 이진트리를 동적으로 변환하여 사용한다. 
	- 데이터의 증감에 따라 버킷을 쪼개거나 합치고 버킷을 포인터로 가리키는 인덱스 테이블 생성/유지를 해야한다.
	메모리 관리 리소스가 들어간다. 동적해싱같은경우 같으면 데이터가 증가해도 검색속도가 유지가 된다. 정적해싱 같은경우 
	-데이터가 증가해도 검색의 성능이 유지되며 메모리 낭비가 적다.
	- 해시테이블 대신 trie(트리이) 자료구조를 이용한다. 

확장해싱(동적해싱의 기법중하나)
	- 배열의 크기만 동적으로 잡은것 이 아니라 인덱스의 구조를 조절하기 위해 해쉬함수의 동적변경을 허용하는 기법
	- 디렉터리라와 버킷으로 구성된 2단계 구조.

충돌이 났을때 해결하는 기법(동적해싱에만 관련된 이야기)
	-개방 주소법(순차적) : 충돌이 났을때 다른 주소를 반복적으로 탐색하는 방법. 연결포인터를 사용하지 않고, 상대적으로 속도가 빠르다.
				- 선형검색법(Linear probing)
					: 충돌이 났다면 충돌 위치에서 테이블 순으로 순차검색을 한다.비어있는지 없는지 있는지 찾는거야. 0x4 0x8 0x12
					1차원 배열구조로 되어있다.
					그냥 포인터 연산으로 들어가면 되곘지 그냥. (배열처럼)
				- 2차 검색법(quadratic probing)
					:선형검색법의 제 1 밀집현상. 충돌된 근처에만 다닥다닥 붙어있을수 있다. (문제점)
					:원래주소로 부터 다음 주소로 결정하는 거리가 1, 4, 9, 16의 떨어진 거리만큼 차례대로 검색 이렇게 제곱으로 가는것이다.
				- 이중 해싱법(double hashing) : 해싱값을 해싱함수에 다시 집어 넣어 넣는것
				- 무작위 검색법(radom probing) : 빈 주소 공간을 찾을때까지 난수로 실행해서 검색. 몇번째 
	-폐쇄 주소법
		- 해쉬 체이닝(hash chinging) : 똑같은 키값이 들어오면 이어서 연결리스트처럼 연결. 총돌이 발생한 레코드들을 연결리스트로 연결하는 방법. 테이블은 포인터 배열로 만들고 각 버킷에 할당되는 레코드들을 체인으로 연결하는 방법.
		- 독립 오버플로우 구역(Chianing with separate overflow area) : 제일 많이 쓴다. 독립된 구역을 만든다고 생각하면 돼. 
		완벽한 해슁함수는 상수시간내에 보장되겠지.
			: 오버플로우 된 레코드들을 별도의 오버플로우 지역에 저장
			: 오버플로우 된 레코드들을 처리하는 기법으로 가장 많이 쓰인다.
			충돌이 발생하면 오버플로우 구역에다가 던져놓고 포인터로 연결한뒤 순차적으로 검색을 하게 된다.



			

*/