#pragma once

/*
해싱(Hashing)
	사용처 
	보안 : 데이터의 위변조를 막기 위해 전자서명이나 보안 알고리즘에 사용
	자료 구조 : 기억 공간에 저장된 정보를 보다 빠르게 검색하기 위해
	상대주소가 아닌 해시 테이블을 생성하는 방식.

	대부분의 탐색 방법들은 탐색 키를 저장된 키 값과 반복적으로
	비교해 가며 원하는 항목에 접근하게 된다.
	반면 해싱은 키값에 직접 산술적인 연산을 적용하여 
	항목이 저장되어 있는 테이블의 주소를 계산하여 항목에 접근한다.
	이렇게 키 값의 연산에 의해 직접 접근이 가능 구조를 
	해시 테이블이라고 부르고, 해시 테이블을 이용한 탐색을 해싱이라 한다.

	키들의 비교에 의한 탐색 방법은 정렬이 안되어 있으면 o(n)이며
	정렬이 되어있다면 o(log n)이다.
	정렬이 되어있는 경우의 시간 복잡도가 o(logn)인건 이진탐색 알고리즘이나
	이진탐색트리.

	해싱이 나오게 된 배경은, 위의 시간복잡도 보다 더욱 빠른 탐색을 필요로 할 때다.
	해싱은 이론적으로 o(1)의 시간안에 탐색을 끝마칠수 있다.
	보통 dictionary(사전구조)와 같은 자료구조를 구현할 때 최상의 선택이 된다.

	사전 구조는 다른말로 map이나 table로 불리기도 한다.
	사전 구조는 탐색 키, 그리고 탐색 키와 관련있는 값 이렇게
	두가지 종류의 필드를 가진다.

단어 정리
해싱 함수(Hashing function)
	- 키값으로부터 레코드의 물리적 주소로 사상시키는 함수
	- 데이터의 무결성 검증, 변조 여부를 파악하기 위해 임의 길이 메세지를
	고정길이 메세지로 변환해서 사용한다.
해시 키(hash key)
	- 해싱 함수가 레코드 주소를 계산하기 위해 사용하는 레코드의 키값을 말함.
해시 테이블(hash table)
	- 해싱 함수에 의해 계산된 주소
	- 키 연산에 의해 직접 접근이 가능한 구조의 기억장소
버킷(bucket)
	- 하나의 주소를 가지면서 하나 이상의 레코드를 저장할 수 있는 파일의 한 구역
	- 크기가 같은 주소에 포함 가능한 레코드의 수
	- 여러개의 슬롯으로 구성됨
슬롯(slot)
	- 한개의 레코드를 저장 할 수 있는 공간.
직접파일(direct file)
	- 해싱 방법을 기초로 하여 만들어진 파일
	- 레코드를 식별하기 위한 키 값과 저장 장치에 저장되어 있는
	레코드 사이의 사상 관계가 성립되어야 함.
충돌
	- 서로 다른 레코드들이 같은 주소로 변환되는 경우
오버 플로우
	- 더 이상 빈자리가 없는 과잉상태
	- 버킷에 레코드들이 가득 찬 상태

해싱 구현 기법
	정적 해싱(static hashing)
		- 고정 크기의 배열을 이용한 방법.
		- 버킷 주소의 집합을 고정
		- 현재 파일의 크기를 고려하여 해시함수를 결정한다.
		- 미래의 어떤 시점을 기점으로 파일 크기를 예상하여 해시 함수를 결정한다.
		- 파일의 크기가 커짐에 따라 주기적으로 해싱 구조를 재구성을 해야한다.
		- 비교적 구현이 쉽고 간단하다.
		- 버킷의 크기를 너무 작게 잡으면 오버플로우가 나고,
		너무 크게잡으면 메모리 낭비의 우려가 있다.
		- 해시 테이블을 너무 작게 잡으면 충돌의 우려가 있다.


	해싱 함수 기법
		- 제산법
			나머지 연산자를 이용하여 버킷주소를 계산하는 방법.
			버킷 주소 = key % 전체 버킷 크기
			해시된 주소가 고르게 분포되지 않을 수 있기 때문에 일반적으로 
			전체 버킷의 크기를 소수(prime number)로 하여 성능을 향상시킨다.
			부하율(load factor, 전체 버킷에서 사용중인 버킷의 비율) 70 ~ 80 퍼센트가 적당.

		- 중간 제곱법
			키 값을 제곱한 후 결과값의 중간 부분에 있는 몇비트만 선택하여 주소로 사용
			제곱된 결과의 중간 비트는 일반적으로 모든 키값의 영향을 받기 때문에 
			키를 구성하는 일부 문자가 같을지라도 서로 다른 결과값을 가질 확률이 높다.

		- 폴딩법(folding)
			키를 마지막 부분을 제외한 모든 부분의 길이가 동일하게 여러 부분으로 
			나누고, 이들 부분을 모두 더하거나, XOR연산을 하여서 버킷주소로 
			이용하는 방법이다.
			이동 폴딩(shift folding) : 각 부분의 값을 계산하기 위해 마지막을 제외한
			모든 부분을 이동시켜 최하위 비트가 마지막 부분의 자리와 일치하도록 
			우측 끝을 맞추어 더한 값을 버킷 주소로 사용하는 방법.
			경계 폴딩(boundary folding) : 원래의 키값을 여러 부분으로 나눈뒤 ,
			나누어진 각 부분의 경계선을 종이 접듯이 접어 역으로 정렬한 다음 같은 자리에
			위치한 수를 버킷의 주소로 사용하는 방법.

		- 숫자 분석법(digit - analysis)
			키를 구성하는 수들이 모든 키들 내에서 각 자리별로
			어떤 분포인지를 조사하여 비교적 고른 분포를 나타내는 자릿 수를
			필요한 만큼 선택하여 버킷 주소로 쓰는 방법
			파일의 키값이 이미 알려진 정적 파일인 경우에 유용하다.
			비슷한 숫자 배열이 나오는 비트는 제거하고 중복이 적은 비트 선택

		- 기수 변환법(radix-exchange)
			어떤 진법으로 변환된 키를 다른 진법으로 간주하고 키를 변환시켜서 
			버킷의 주소를 얻는 방법
			배열의 크기가 10의 거듭제곱으로 표현되어 변환된 해당 버킷 주소가 배열의 
			크기를 초과할대는 버킷 주소의 최하위 자리부터 배열의 크기가 허용하는
			거듭제곱 자리수만큼 취하여 주소로 사용한다.


*/